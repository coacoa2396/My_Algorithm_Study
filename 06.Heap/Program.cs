namespace _06.Heap
{
    internal class Program
    {
        /*************************************************************************************
        * 힙 (Heap)
        * 
        * 부모 노드가 자식노드보다 우선순위가 높은 속성을 만족하는 트리기반의 자료구조
        * 많은 자료 중 우선순위가 가장 높은 요소를 빠르게 가져오기 위해 사용
        *************************************************************************************/

        // <힙 구현>
        // 힙은 노드들이 트리의 왼쪽부터 채운 완전이진트리를 구조를 가지며
        // 부모 노드가 두 자식노드보다 우선순위가 높은 값을 위치시킴
        // 힙 상태를 만족하는 경우 가장 최상단 노드가 모든 노드 중 우선순위가 가장 높음
        //
        //               2
        //       ┌───────┴───────┐
        //       8               52
        //   ┌───┴───┐       ┌───┴───┐
        //   13      37      67      92
        // ┌─┴─┐   ┌─┘
        // 17  43  52

        // 최소힙과 최대힙이 있다
        // 최소힙은 우선순위의 숫자가 낮은 순대로 출력 되는 것이고
        // 최대힙은 우선순위의 숫자가 높은 순대로 출력 되는 것이다


        // <힙 노드 삽입>
        // 1. 힙의 최고 깊이, 최우측에 새 노드를 추가 : 7을 추가해보자
        //
        //               2
        //       ┌───────┴───────┐
        //       8               52
        //   ┌───┴───┐       ┌───┴───┐
        //   13      37      67      92
        // ┌─┴─┐   ┌─┴─┐
        // 17  43  52 (7)
        //
        // 2. 삽입한 노드와 부모 노드를 비교하여 우선순위가 더 높은 경우 교체
        //
        //               2                               2                               2
        //       ┌───────┴───────┐               ┌───────┴───────┐               ┌───────┴───────┐
        //       8               52              8               52             (7)              52
        //   ┌───┴───┐       ┌───┴───┐  =>   ┌───┴───┐       ┌───┴───┐  =>   ┌───┴───┐       ┌───┴───┐
        //   13      37      67      92      13     (7)      67      92      13      8       67      92
        // ┌─┴─┐   ┌─┴─┐                   ┌─┴─┐   ┌─┴─┐                   ┌─┴─┐   ┌─┴─┐
        // 17  43  52 (7)                  17  43  52  37                  17  43  52  37
        //
        // 3. 더이상 교체되지 않을때까지 과정을 반복
        //
        //               2                               2
        //       ┌───────┴───────┐               ┌───────┴───────┐
        //      (7)              52              7               52
        //   ┌───┴───┐       ┌───┴───┐  =>   ┌───┴───┐       ┌───┴───┐
        //   13      8       67      92      13      8       67      92
        // ┌─┴─┐   ┌─┴─┐                   ┌─┴─┐   ┌─┴─┐
        // 17  43  52  37                  17  43  52  37


        // <힙 노드 삭제>
        // 1. 최상단의 노드와 마지막(제일 깊은 최우측) 노드를 교체한 뒤 마지막(제일 깊은 최우측) 노드를 삭제 : 2를 삭제해보자
        //
        //              (2)                             (37)                           (37)
        //       ┌───────┴───────┐               ┌───────┴───────┐              ┌───────┴───────┐
        //       7               52              7               52             7               52
        //   ┌───┴───┐       ┌───┴───┐  =>   ┌───┴───┐       ┌───┴───┐  =>  ┌───┴───┐       ┌───┴───┐
        //   13      8       67      92      13      8       67      92     13      8       67      92
        // ┌─┴─┐   ┌─┴─┐                   ┌─┴─┐   ┌─┴─┐                  ┌─┴─┐   ┌─┘
        // 17  43  52 (37)                 17  43  52 (2)                 17  43  52
        //
        // 2. 교체된 노드와 두 자식 노드를 비교하여 우선순위가 더 높은 노드와 교체
        //
        //              (37)                             7                               7
        //       ┌───────┴───────┐               ┌───────┴───────┐               ┌───────┴───────┐
        //       7               52             (37)             52              8               52
        //   ┌───┴───┐       ┌───┴───┐  =>   ┌───┴───┐       ┌───┴───┐  =>   ┌───┴───┐       ┌───┴───┐
        //   13      8       67      92      13      8       67      92      13     (37)     67      92
        // ┌─┴─┐   ┌─┘                     ┌─┴─┐   ┌─┘                     ┌─┴─┐   ┌─┘
        // 17  43  52                      17  43  52                      17  43  52
        //
        // 3. 더이상 교체되지 않을때까지 과정을 반복
        //
        //               7                               7
        //       ┌───────┴───────┐               ┌───────┴───────┐
        //       8               52              8               52
        //   ┌───┴───┐       ┌───┴───┐  =>   ┌───┴───┐       ┌───┴───┐
        //   13     (37)     67      92      13      37      67      92
        // ┌─┴─┐   ┌─┘                     ┌─┴─┐   ┌─┘
        // 17  43  52                      17  43  52


        // <힙 구현>
        // 힙의 완전이진트리 특징의 경우 배열을 통해서 구현하기 좋음
        // 노드의 위치를 배열에 순서대로 저장
        // 노드가 위치한 인덱스에 연산을 진행하여 노드 이동이 가능
        // 
        // 해당 노드의 index : n
        // 부모로 이동         : (n - 1) / 2
        // 왼쪽자식으로 이동   : 2 * n + 1
        // 오른쪽자식으로 이동 : 2 * n + 2
        //
        // 다른 방법으로 말하면
        //
        // 부모 노드 Index : n
        // 좌측 자식 노드 Index : n * 2
        // 우측 자식 노드 Index : n * 2 + 1
        //
        //        0
        //    ┌───┴───┐
        //    1       2       ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
        //  ┌─┴─┐   ┌─┴─┐ =>  │0│1│2│3│4│5│6│7│8│9│
        //  3   4   5   6     └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
        // ┌┴┐ ┌┘
        // 7 8 9


        static void Main(string[] args)
        {
            // 응급실
            Queue<string> queue = new Queue<string>();

            queue.Enqueue("환자 1 - 감기");
            queue.Enqueue("환자 2 - 타박상");
            queue.Enqueue("환자 3 - 심장마비");

            while (queue.Count > 0)
            {
                Console.WriteLine(queue.Dequeue());
            }
            // 이러면 심장마비 환자는 죽는다

            PriorityQueue<string, int> pq = new PriorityQueue<string, int>();

            pq.Enqueue("환자 1 - 감기", 5);
            pq.Enqueue("환자 2 - 타박상", 8);
            pq.Enqueue("환자 3 - 심장마비", 1);
            pq.Enqueue("환자 4 - 교통사고", 3);
            pq.Enqueue("환자 5 - 탈모", 9);

            while (pq.Count > 0)
            {
                Console.WriteLine(pq.Dequeue());
            }
            // 이렇게 하면 우선순위대로(숫자가 작은 순서대로) 출력되게 된다

            // 내림차순 : int 우선순위에 *-1을 적용하여 사용
            PriorityQueue<string, int> pq1 = new PriorityQueue<string, int>();

            pq.Enqueue("data1", -1);
            pq.Enqueue("data2", -2);
            pq.Enqueue("data3", -3);
            pq.Enqueue("data4", -4);
            pq.Enqueue("data5", -5);
            // 이러면 -5가 제일 작은값이라 data5부터 출력됨
        }
    }
}
